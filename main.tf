terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.0"
    }
    restapi = {
      source  = "Mastercard/restapi"
      version = "~> 1.19"
    }
  }
}

provider "aws" {
  region = var.region
}


data "http" "zenml_login" {
  count = var.zenml_api_key != "" ? 1 : 0
  url = "${var.zenml_server_url}/api/v1/login"

  method = "POST"

  request_body = "password=${urlencode(var.zenml_api_key)}"

  request_headers = {
    Content-Type = "application/x-www-form-urlencoded"
  }
}

provider "restapi" {
  alias                = "zenml_api"
  uri                  = var.zenml_server_url
  write_returns_object = true

  headers = {
    Authorization = "Bearer ${var.zenml_api_key == "" ? var.zenml_api_token : jsondecode(data.http.zenml_login[0].response_body).access_token}"
  }
}

data "aws_caller_identity" "current" {}

data "http" "zenml_info" {
  url = "${var.zenml_server_url}/api/v1/info"
}

locals {
  zenml_pro_tenant_id = try(jsondecode(data.http.zenml_info.response_body).metadata["tenant_id"], null)
  zenml_version = jsondecode(data.http.zenml_info.response_body).version
  zenml_pro_tenant_iam_role_name = local.zenml_pro_tenant_id != null ? "zenml-${local.zenml_pro_tenant_id}" : ""
  zenml_pro_tenant_iam_role = local.zenml_pro_tenant_id != null ? "arn:aws:iam::${var.zenml_pro_aws_account}:role/${local.zenml_pro_tenant_iam_role_name}" : ""
  # Use inter-AWS-account implicit authentication when connected to a ZenML Pro tenant and
  # not using SkyPilot. SkyPilot cannot be used with implicit authentication because it does
  # not support the AWS temporary credentials generated by ZenML from the implicit authentication
  # flow.
  use_implicit_auth = local.zenml_pro_tenant_id != null && var.orchestrator != "skypilot"
}

resource "random_id" "resource_name_suffix" {
  # This will generate a string of 12 characters, encoded as base64 which makes
  # it 8 characters long
  byte_length = 6
}

resource "aws_s3_bucket" "artifact_store" {
  bucket = "zenml-${data.aws_caller_identity.current.account_id}-${random_id.resource_name_suffix.hex}"
}

resource "aws_ecr_repository" "container_registry" {
  name = "zenml-${random_id.resource_name_suffix.hex}"
}


resource "aws_iam_user" "iam_user" {
  count = local.use_implicit_auth ? 0 : 1
  name = "zenml-${random_id.resource_name_suffix.hex}"
}

resource "aws_iam_user_policy" "assume_role_policy" {
  count = local.use_implicit_auth ? 0 : 1
  name = "AssumeRole"
  user = aws_iam_user.iam_user[0].name

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = "sts:AssumeRole"
        Resource = "*"
      }
    ]
  })
}

resource "aws_iam_access_key" "iam_user_access_key" {
  count = local.use_implicit_auth ? 0 : 1
  user = aws_iam_user.iam_user[0].name
}

resource "aws_iam_role" "stack_access_role" {
  name               = "zenml-${random_id.resource_name_suffix.hex}"
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          AWS = local.use_implicit_auth ? local.zenml_pro_tenant_iam_role : aws_iam_user.iam_user[0].arn
        }
        Action = "sts:AssumeRole"
      }
    ]
  })
}

resource "aws_iam_role_policy" "s3_policy" {
  name = "S3Policy"
  role = aws_iam_role.stack_access_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:ListBucket",
          "s3:GetObject",
          "s3:PutObject",
          "s3:DeleteObject"
        ]
        Resource = [
          aws_s3_bucket.artifact_store.arn,
          "${aws_s3_bucket.artifact_store.arn}/*"
        ]
      }
    ]
  })
}

resource "aws_iam_role_policy" "ecr_policy" {
  name = "ECRPolicy"
  role = aws_iam_role.stack_access_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "ecr:DescribeRegistry",
          "ecr:BatchGetImage",
          "ecr:DescribeImages",
          "ecr:BatchCheckLayerAvailability",
          "ecr:GetDownloadUrlForLayer",
          "ecr:InitiateLayerUpload",
          "ecr:UploadLayerPart",
          "ecr:CompleteLayerUpload",
          "ecr:PutImage"
        ]
        Resource = aws_ecr_repository.container_registry.arn
      },
      {
        Effect = "Allow"
        Action = "ecr:GetAuthorizationToken"
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = [
          "ecr:DescribeRepositories",
          "ecr:ListRepositories"
        ]
        Resource = "arn:aws:ecr:${var.region}:${data.aws_caller_identity.current.account_id}:repository/*"
      }
    ]
  })
}

# Client permissions needed for the SageMaker step operator
resource "aws_iam_role_policy" "sagemaker_training_jobs_policy" {
  name = "SageMakerTrainingJobsPolicy"
  role = aws_iam_role.stack_access_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "sagemaker:CreateTrainingJob",
          "sagemaker:DescribeTrainingJob",
          "logs:Describe*",
          "logs:GetLogEvents"
        ]
        Resource = "*"
      },
      {
        Effect = "Allow"
        Action = "iam:PassRole"
        Resource = aws_iam_role.sagemaker_runtime_role.arn
      }
    ]
  })
}


# Client permissions needed for the SageMaker orchestrator
resource "aws_iam_role_policy" "sagemaker_pipelines_policy" {
  count = var.orchestrator == "sagemaker" ? 1 : 0
  name = "SageMakerPipelinesPolicy"
  role = aws_iam_role.stack_access_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "sagemaker:CreatePipeline",
          "sagemaker:StartPipelineExecution",
          "sagemaker:DescribePipeline",
          "sagemaker:DescribePipelineExecution"
        ]
        Resource = "*"
      }
    ]
  })
}


resource "aws_iam_role_policy" "skypilot_policy" {
  count = var.orchestrator == "skypilot" ? 1 : 0
  name = "SkyPilotPolicy"
  role = aws_iam_role.stack_access_role.id

  # NOTE: these are minimal AWS SkyPilot permissions taken from https://skypilot.readthedocs.io/en/latest/cloud-setup/cloud-permissions/aws.html#aws
  policy = jsonencode({
    Version: "2012-10-17",
    Statement: [
      {
          Effect: "Allow",
          Action: "ec2:RunInstances",
          Resource: "arn:aws:ec2:*::image/ami-*"
      },
      {
          Effect: "Allow",
          Action: "ec2:RunInstances",
          Resource: [
              "arn:aws:ec2:*:${data.aws_caller_identity.current.account_id}:instance/*",
              "arn:aws:ec2:*:${data.aws_caller_identity.current.account_id}:network-interface/*",
              "arn:aws:ec2:*:${data.aws_caller_identity.current.account_id}:subnet/*",
              "arn:aws:ec2:*:${data.aws_caller_identity.current.account_id}:volume/*",
              "arn:aws:ec2:*:${data.aws_caller_identity.current.account_id}:security-group/*"
          ]
      },
      {
          Effect: "Allow",
          Action: [
              "ec2:TerminateInstances",
              "ec2:DeleteTags",
              "ec2:StartInstances",
              "ec2:CreateTags",
              "ec2:StopInstances"
          ],
          Resource: "arn:aws:ec2:*:${data.aws_caller_identity.current.account_id}:instance/*"
      },
      {
          Effect: "Allow",
          Action: [
              "ec2:Describe*"
          ],
          Resource: "*"
      },
      {
          Effect: "Allow",
          Action: [
              "ec2:CreateSecurityGroup",
              "ec2:AuthorizeSecurityGroupIngress"
          ],
          Resource: "arn:aws:ec2:*:${data.aws_caller_identity.current.account_id}:*"
      },
      {
          Effect: "Allow",
          Action: [
              "iam:GetRole",
              "iam:PassRole"
          ],
          Resource: [
              "arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/skypilot-v1"
          ]
      },
      {
          Effect: "Allow",
          Action: [
              "iam:GetInstanceProfile"
          ],
          Resource: "arn:aws:iam::${data.aws_caller_identity.current.account_id}:instance-profile/skypilot-v1"
      },
      {
          Effect: "Allow",
          Action: "iam:CreateServiceLinkedRole",
          Resource: "*",
          Condition: {
              StringEquals: {
                  "iam:AWSServiceName": "spot.amazonaws.com"
              }
          }
      },
      {
          Effect: "Allow",
          Action: [
              "iam:GetRole",
              "iam:PassRole",
              "iam:CreateRole",
              "iam:AttachRolePolicy"
          ],
          Resource: [
              "arn:aws:iam::${data.aws_caller_identity.current.account_id}:role/skypilot-v1"
          ]
      },
      {
          Effect: "Allow",
          Action: [
              "iam:GetInstanceProfile",
              "iam:CreateInstanceProfile",
              "iam:AddRoleToInstanceProfile"
          ],
          Resource: "arn:aws:iam::${data.aws_caller_identity.current.account_id}:instance-profile/skypilot-v1"
      }
    ]
  })
}

resource "aws_iam_role" "sagemaker_runtime_role" {
  name               = "zenml-${random_id.resource_name_suffix.hex}-sagemaker"
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          Service = "sagemaker.amazonaws.com"
        }
        Action = "sts:AssumeRole"
      }
    ]
  })

  managed_policy_arns = [
    "arn:aws:iam::aws:policy/AmazonSageMakerFullAccess"
  ]
}

# SageMaker runtime permissions
resource "aws_iam_role_policy" "sagemaker_runtime_policy" {
  name = "SageMakerRuntimePolicy"
  role = aws_iam_role.sagemaker_runtime_role.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "s3:GetObject",
          "s3:PutObject",
          "s3:DeleteObject",
          "s3:AbortMultipartUpload"
        ]
        Resource = [
          aws_s3_bucket.artifact_store.arn,
          "${aws_s3_bucket.artifact_store.arn}/*"
        ]
      }
    ]
  })
}


locals {
  # The orchestrator configuration is different depending on the orchestrator
  # chosen by the user. We use the `orchestrator` variable to determine which
  # configuration to use and construct a local variable `orchestrator_config` to
  # hold the configuration.
  orchestrator_config = {
    local = {
      "flavor": "local",
    }
    sagemaker = {
      "flavor": "sagemaker",
      "service_connector_index": 0,
      "configuration": {
        "location": "${var.region}",
        "execution_role": "${aws_iam_role.sagemaker_runtime_role.arn}"
      }
    }
    skypilot = {
      "flavor": "vm_aws",
      "service_connector_index": 0,
      "configuration": {
        "region": "${var.region}"
      }
    }
  }
  # The service connector configuration is different depending on whether we are
  # using the ZenML Pro tenant or not. We use the `use_implicit_auth` local
  # variable to determine which configuration to use and construct a local
  # variable `service_connector_config` to hold the configuration.
  service_connector_config = local.use_implicit_auth ? jsonencode({
    "type": "aws",
    "auth_method": "implicit",
    "configuration": {
      "region": "${var.region}",
      "role_arn": "${aws_iam_role.stack_access_role.arn}"
    }
  }) : jsonencode({
    "type": "aws",
    "auth_method": "iam-role",
    "configuration": {
      "aws_access_key_id": "${aws_iam_access_key.iam_user_access_key[0].id}",
      "aws_secret_access_key": "${aws_iam_access_key.iam_user_access_key[0].secret}",
      "region": "${var.region}",
      "role_arn": "${aws_iam_role.stack_access_role.arn}"
    }
  })
}

resource "terraform_data" "zenml_stack_deps" {
  input = [
    var.orchestrator,
    random_id.resource_name_suffix,
    var.zenml_stack_name,
    var.region,
    var.zenml_server_url,
    var.zenml_pro_aws_account,
  ]
}

resource "restapi_object" "zenml_stack" {
  provider = restapi.zenml_api
  path = "/api/v1/stacks"
  create_path = "/api/v1/workspaces/default/full-stack"
  data = <<EOF
{
  "name": "${var.zenml_stack_name == "" ? "terraform-aws-${random_id.resource_name_suffix.hex}" : var.zenml_stack_name}",
  "description": "Deployed with the ZenML AWS Stack Terraform module in the '${data.aws_caller_identity.current.account_id}' account and '${var.region}' region.",
  "labels": {
    "zenml:provider": "aws",
    "zenml:deployment": "${var.zenml_stack_deployment}"
  },
  "service_connectors": [
    ${local.service_connector_config}
  ],
  "components": {
    "artifact_store": {
      "flavor": "s3",
      "service_connector_index": 0,
      "configuration": {
        "path": "s3://${aws_s3_bucket.artifact_store.bucket}"
      }
    },
    "container_registry":{
      "flavor": "aws",
      "service_connector_index": 0,
      "configuration": {
        "uri": "${data.aws_caller_identity.current.account_id}.dkr.ecr.${var.region}.amazonaws.com",
        "default_repository": "${aws_ecr_repository.container_registry.name}"
      }
    },
    "orchestrator": ${jsonencode(local.orchestrator_config[var.orchestrator])},
    "step_operator": {
      "flavor": "sagemaker",
      "service_connector_index": 0,
      "configuration": {
        "role": "${aws_iam_role.sagemaker_runtime_role.arn}",
        "bucket": "${aws_s3_bucket.artifact_store.bucket}"
      }
    },
    "image_builder": {
      "flavor": "local"
    }
  }
}
EOF
  lifecycle {
    # Given that we don't yet support updating a full stack, we force a new
    # resource to be created whenever any of the inputs change.
    replace_triggered_by = [
      terraform_data.zenml_stack_deps
    ]
  }

  # Depends on all other resources
  depends_on = [
    aws_s3_bucket.artifact_store,
    aws_ecr_repository.container_registry,
    aws_iam_user.iam_user[0],
    aws_iam_user_policy.assume_role_policy[0],
    aws_iam_access_key.iam_user_access_key,
    aws_iam_role.stack_access_role,
    aws_iam_role.sagemaker_runtime_role,    
    aws_iam_role_policy.s3_policy,
    aws_iam_role_policy.ecr_policy,
    aws_iam_role_policy.skypilot_policy[0],
    aws_iam_role_policy.sagemaker_training_jobs_policy,
    aws_iam_role_policy.sagemaker_pipelines_policy[0],
    aws_iam_role_policy.sagemaker_runtime_policy,
  ]
}